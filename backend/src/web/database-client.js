/**
 * æ–‡ä»¶è·¯å¾„: src/web/database-client.js
 * åŠŸèƒ½æ¦‚è¿°: SCPPER-CN Web åº”ç”¨æ•°æ®åº“å®¢æˆ·ç«¯æ¨¡å—
 * 
 * ä¸»è¦åŠŸèƒ½:
 * - ä¸“é—¨ä¸º Web åº”ç”¨ä¼˜åŒ–çš„ Prisma æ•°æ®åº“å®¢æˆ·ç«¯
 * - å•ä¾‹æ¨¡å¼ç¡®ä¿å…¨å±€å”¯ä¸€è¿æ¥æ± å®ä¾‹
 * - é’ˆå¯¹ 10-20 å¹¶å‘ç”¨æˆ·çš„è¿æ¥æ± ä¼˜åŒ–é…ç½®
 * - Web åº”ç”¨åœºæ™¯ä¸‹çš„æ•°æ®åº“æ“ä½œå°è£…
 * - ä¼˜é›…çš„è¿æ¥å…³é—­å’Œèµ„æºæ¸…ç†
 * - å¤šç¯å¢ƒæ•°æ®åº“ URL æ”¯æŒ
 * 
 * æ ¸å¿ƒç‰¹æ€§:
 * - å•ä¾‹è®¾è®¡æ¨¡å¼ï¼Œé¿å…é‡å¤è¿æ¥åˆ›å»º
 * - Web ä¸“ç”¨è¿æ¥æ± é…ç½®ï¼ˆä¸æ‰¹å¤„ç†åŒºåˆ†ï¼‰
 * - è¿›ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†å’Œè‡ªåŠ¨æ¸…ç†
 * - å¼€å‘/ç”Ÿäº§ç¯å¢ƒçš„æ—¥å¿—çº§åˆ«åŒºåˆ†
 * - æ•°æ®åº“è¿æ¥çŠ¶æ€ç®¡ç†å’Œç›‘æ§
 * 
 * é€‚ç”¨åœºæ™¯:
 * - Fastify Web æœåŠ¡å™¨æ•°æ®åº“æ“ä½œ
 * - API æ¥å£çš„æ•°æ®æŸ¥è¯¢å’Œæ“ä½œ
 * - ç”¨æˆ·ç•Œé¢çš„æ•°æ®å±•ç¤ºå’Œäº¤äº’
 */

import { PrismaClient } from '@prisma/client';
class WebDatabaseClient {
  constructor() {
    if (WebDatabaseClient.instance) {
      return WebDatabaseClient.instance;
    }

    this.prisma = new PrismaClient({
      log: process.env.NODE_ENV === 'development' ? ['warn', 'error'] : ['error'],
      datasources: {
        db: {
          url: process.env.DATABASE_WEB_URL || process.env.DATABASE_URL
        }
      }
    });

    // æ³¨å†Œå…³é—­å¤„ç†
    process.on('beforeExit', () => this.disconnect());
    process.on('SIGINT', () => this.disconnect());
    process.on('SIGTERM', () => this.disconnect());

    WebDatabaseClient.instance = this;
  }

  /**
   * è·å–Prismaå®¢æˆ·ç«¯å®ä¾‹
   */
  getClient() {
    return this.prisma;
  }

  /**
   * å¸¸ç”¨æŸ¥è¯¢æ–¹æ³• - è·å–é¡µé¢åˆ—è¡¨ï¼ˆåˆ†é¡µï¼‰
   */
  async getPages(options = {}) {
    const { 
      page = 1, 
      limit = 20, 
      category = null, 
      orderBy = 'rating',
      order = 'desc',
      search = null 
    } = options;

    const skip = (page - 1) * limit;
    
    const where = {
      isDeleted: false,
      ...(category && { category }),
      ...(search && {
        OR: [
          { title: { contains: search, mode: 'insensitive' } },
          { url: { contains: search, mode: 'insensitive' } }
        ]
      })
    };

    const [pages, total] = await Promise.all([
      this.prisma.page.findMany({
        where,
        orderBy: { [orderBy]: order },
        skip,
        take: limit,
        select: {
          url: true,
          title: true,
          category: true,
          rating: true,
          voteCount: true,
          createdByUser: true,
          createdAt: true,
          tags: true,
          wilsonScore: true,
          upVoteRatio: true
        }
      }),
      this.prisma.page.count({ where })
    ]);

    return {
      pages,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  }

  /**
   * è·å–å•ä¸ªé¡µé¢è¯¦æƒ…
   */
  async getPage(url) {
    return await this.prisma.page.findUnique({
      where: { url, isDeleted: false },
      include: {
        voteRecords: {
          take: 100, // é™åˆ¶æŠ•ç¥¨è®°å½•æ•°é‡
          orderBy: { timestamp: 'desc' }
        },
        attributions: {
          where: { isCurrent: true },
          orderBy: { orderIndex: 'asc' }
        },
        alternateTitles: true
      }
    });
  }

  /**
   * è·å–ç”¨æˆ·ç»Ÿè®¡ä¿¡æ¯
   */
  async getUser(wikidotId) {
    return await this.prisma.user.findUnique({
      where: { wikidotId },
      select: {
        wikidotId: true,
        displayName: true,
        totalRating: true,
        pageCount: true,
        pageCountScp: true,
        pageCountTale: true,
        pageCountGoiFormat: true,
        joinTime: true,
        isActive: true,
        lastAnalyzedAt: true
      }
    });
  }

  /**
   * è·å–ç”¨æˆ·åˆ›å»ºçš„é¡µé¢
   */
  async getUserPages(wikidotId, options = {}) {
    const { page = 1, limit = 20 } = options;
    const skip = (page - 1) * limit;

    const [pages, total] = await Promise.all([
      this.prisma.page.findMany({
        where: { 
          createdByWikidotId: wikidotId,
          isDeleted: false 
        },
        orderBy: { rating: 'desc' },
        skip,
        take: limit,
        select: {
          url: true,
          title: true,
          category: true,
          rating: true,
          voteCount: true,
          createdAt: true,
          wilsonScore: true
        }
      }),
      this.prisma.page.count({ 
        where: { 
          createdByWikidotId: wikidotId,
          isDeleted: false 
        } 
      })
    ]);

    return { pages, total };
  }

  /**
   * æœç´¢é¡µé¢
   */
  async searchPages(query, options = {}) {
    const { limit = 20 } = options;

    return await this.prisma.page.findMany({
      where: {
        isDeleted: false,
        OR: [
          { title: { contains: query, mode: 'insensitive' } },
          { url: { contains: query, mode: 'insensitive' } },
          { tags: { has: query } }
        ]
      },
      orderBy: [
        { wilsonScore: 'desc' },
        { rating: 'desc' }
      ],
      take: limit,
      select: {
        url: true,
        title: true,
        category: true,
        rating: true,
        voteCount: true,
        createdByUser: true,
        tags: true,
        wilsonScore: true
      }
    });
  }

  /**
   * è·å–ç»Ÿè®¡æ•°æ®ï¼ˆé¦–é¡µç”¨ï¼‰
   */
  async getStatistics() {
    const [
      totalPages,
      totalUsers,
      totalVotes,
      recentPages
    ] = await Promise.all([
      this.prisma.page.count({ where: { isDeleted: false } }),
      this.prisma.user.count(),
      this.prisma.voteRecord.count(),
      this.prisma.page.findMany({
        where: { isDeleted: false },
        orderBy: { createdAt: 'desc' },
        take: 5,
        select: {
          url: true,
          title: true,
          createdByUser: true,
          rating: true,
          createdAt: true
        }
      })
    ]);

    return {
      totalPages,
      totalUsers,
      totalVotes,
      recentPages
    };
  }

  /**
   * å¥åº·æ£€æŸ¥
   */
  async healthCheck() {
    try {
      await this.prisma.$queryRaw`SELECT 1`;
      return { status: 'healthy' };
    } catch (error) {
      return { status: 'unhealthy', error: error.message };
    }
  }

  /**
   * å…³é—­è¿æ¥
   */
  async disconnect() {
    if (this.prisma) {
      await this.prisma.$disconnect();
      console.log('ğŸ”Œ Webæ•°æ®åº“è¿æ¥å·²å…³é—­');
    }
  }
}

// å¯¼å‡ºå•ä¾‹å®ä¾‹
const webDB = new WebDatabaseClient();

export { WebDatabaseClient, webDB };